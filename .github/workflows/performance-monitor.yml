# GitHub Actions Performance Monitoring Pipeline for Crown & Barrel iOS App
# This workflow monitors build performance, test execution, and resource usage

name: Performance Monitor

on:
  schedule:
    # Run daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      monitor_type:
        description: 'Type of performance monitoring to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - build
          - test
          - resource
  push:
    branches: [ main, develop ]
    paths:
      - 'Sources/**'
      - 'Tests/**'
      - '.github/workflows/**'

env:
  PROJECT_NAME: "CrownAndBarrel"
  SCHEME_NAME: "CrownAndBarrel"
  XCODE_VERSION: "16.0"
  IOS_SIMULATOR_NAME: "iPhone 16 Pro"  # Updated to target iPhone 16 Pro specifically
  IOS_SIMULATOR_OS: "26.0"  # Updated to target iOS 26.0 specifically

jobs:
  # Build performance monitoring
  build-performance:
    name: Build Performance Monitor
    runs-on: macos-latest
    if: github.event.inputs.monitor_type == 'build' || github.event.inputs.monitor_type == 'full' || github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}
          
      - name: Install XcodeGen
        run: |
          if ! command -v xcodegen &> /dev/null; then
            echo "Installing XcodeGen..."
            ARCH=$(uname -m)
            echo "Detected architecture: $ARCH"
            
            # Try multiple installation strategies
            # Strategy 1: Direct download (fastest)
            echo "Trying direct download..."
            if curl -L https://github.com/yonaskolb/XcodeGen/releases/latest/download/xcodegen.zip -o xcodegen.zip && unzip xcodegen.zip && sudo mv xcodegen /usr/local/bin/; then
              echo "‚úÖ XcodeGen installed via direct download"
            # Strategy 2: Homebrew with ARM64 forcing
            elif [ "$ARCH" = "arm64" ]; then
              echo "Trying Homebrew with ARM64 forcing..."
              if arch -arm64 /opt/homebrew/bin/brew install xcodegen 2>/dev/null || \
                 arch -arm64 /usr/local/bin/brew install xcodegen 2>/dev/null || \
                 arch -arm64 brew install xcodegen 2>/dev/null; then
                echo "‚úÖ XcodeGen installed via ARM64 Homebrew"
              else
                echo "‚ùå All installation methods failed"
                exit 1
              fi
            # Strategy 3: Standard Homebrew
            else
              echo "Trying standard Homebrew..."
              if brew install xcodegen; then
                echo "‚úÖ XcodeGen installed via standard Homebrew"
              else
                echo "‚ùå Homebrew installation failed"
                exit 1
              fi
            fi
          else
            echo "‚úÖ XcodeGen already available"
          fi
          xcodegen generate
          
      - name: Monitor build performance
        run: |
          echo "Starting build performance monitoring..."
          
          # Record start time
          BUILD_START_TIME=$(date +%s)
          
          # Clean build
          echo "Performing clean build..."
          xcodebuild clean -project "${{ env.PROJECT_NAME }}.xcodeproj" -scheme "${{ env.SCHEME_NAME }}"
          
          # Record clean time
          CLEAN_END_TIME=$(date +%s)
          CLEAN_DURATION=$((CLEAN_END_TIME - BUILD_START_TIME))
          
          # Find the best available iOS 26.0 simulator for performance monitoring
          echo "Looking for available iOS 26.0 simulators for performance monitoring..."
          
          # Check for iPhone 16 Pro with iOS 26.0 first (preferred)
          if xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone 16 Pro.*26.0"; then
            DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro,OS=26.0"
            echo "‚úÖ Found iPhone 16 Pro with iOS 26.0 - using preferred target for performance monitoring"
          # Fallback to any iPhone with iOS 26.0
          elif xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone.*26.0"; then
            # Get first available iPhone with iOS 26.0
            IPHONE_26_LINE=$(xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep "iPhone.*26.0" | head -1)
            IPHONE_NAME=$(echo "$IPHONE_26_LINE" | grep -o 'name:[^,]*' | cut -d: -f2)
            DESTINATION="platform=iOS Simulator,name=$IPHONE_NAME,OS=26.0"
            echo "‚úÖ Found $IPHONE_NAME with iOS 26.0 - using fallback target for performance monitoring"
          else
            echo "‚ùå No iOS 26.0 simulators found, skipping performance monitoring"
            exit 0
          fi
          
          echo "Performing full build with destination: $DESTINATION"
          xcodebuild build \
            -project "${{ env.PROJECT_NAME }}.xcodeproj" \
            -scheme "${{ env.SCHEME_NAME }}" \
            -destination "$DESTINATION" \
            -configuration Release \
            CODE_SIGNING_ALLOWED=NO \
            ONLY_ACTIVE_ARCH=YES \
            VALID_ARCHS="arm64" \
            ARCHS="arm64" \
            ENABLE_BITCODE=NO \
            IPHONEOS_DEPLOYMENT_TARGET=26.0
            
          # Record end time
          BUILD_END_TIME=$(date +%s)
          BUILD_DURATION=$((BUILD_END_TIME - CLEAN_END_TIME))
          TOTAL_DURATION=$((BUILD_END_TIME - BUILD_START_TIME))
          
          # Output performance metrics
          echo "## Build Performance Metrics"
          echo "============================"
          echo "üßπ **Clean Duration**: ${CLEAN_DURATION} seconds"
          echo "üî® **Build Duration**: ${BUILD_DURATION} seconds"
          echo "‚è±Ô∏è **Total Duration**: ${TOTAL_DURATION} seconds"
          echo ""
          echo "## Performance Analysis"
          echo "======================"
          
          # Analyze performance
          if [ $BUILD_DURATION -lt 60 ]; then
            echo "‚úÖ Build performance: EXCELLENT (< 1 minute)"
          elif [ $BUILD_DURATION -lt 120 ]; then
            echo "‚úÖ Build performance: GOOD (< 2 minutes)"
          elif [ $BUILD_DURATION -lt 300 ]; then
            echo "‚ö†Ô∏è Build performance: ACCEPTABLE (< 5 minutes)"
          else
            echo "‚ùå Build performance: POOR (> 5 minutes)"
          fi
          
          # Performance recommendations
          echo ""
          echo "## Performance Recommendations"
          echo "=============================="
          if [ $BUILD_DURATION -gt 120 ]; then
            echo "üîß Consider implementing build caching"
            echo "üîß Review build dependencies and optimization"
            echo "üîß Consider using build parallelization"
          fi
          
          # Store metrics for reporting
          echo "BUILD_DURATION=${BUILD_DURATION}" >> $GITHUB_ENV
          echo "CLEAN_DURATION=${CLEAN_DURATION}" >> $GITHUB_ENV
          echo "TOTAL_DURATION=${TOTAL_DURATION}" >> $GITHUB_ENV

  # Test performance monitoring
  test-performance:
    name: Test Performance Monitor
    runs-on: macos-latest
    if: github.event.inputs.monitor_type == 'test' || github.event.inputs.monitor_type == 'full' || github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}
          
      - name: Setup simulator
        run: |
          xcrun simctl boot "${{ env.IOS_SIMULATOR_NAME }}" || true
          xcrun simctl shutdown "${{ env.IOS_SIMULATOR_NAME }}" || true
          xcrun simctl boot "${{ env.IOS_SIMULATOR_NAME }}"
          
      - name: Install XcodeGen
        run: |
          if ! command -v xcodegen &> /dev/null; then
            echo "Installing XcodeGen..."
            ARCH=$(uname -m)
            echo "Detected architecture: $ARCH"
            
            # Try multiple installation strategies
            # Strategy 1: Direct download (fastest)
            echo "Trying direct download..."
            if curl -L https://github.com/yonaskolb/XcodeGen/releases/latest/download/xcodegen.zip -o xcodegen.zip && unzip xcodegen.zip && sudo mv xcodegen /usr/local/bin/; then
              echo "‚úÖ XcodeGen installed via direct download"
            # Strategy 2: Homebrew with ARM64 forcing
            elif [ "$ARCH" = "arm64" ]; then
              echo "Trying Homebrew with ARM64 forcing..."
              if arch -arm64 /opt/homebrew/bin/brew install xcodegen 2>/dev/null || \
                 arch -arm64 /usr/local/bin/brew install xcodegen 2>/dev/null || \
                 arch -arm64 brew install xcodegen 2>/dev/null; then
                echo "‚úÖ XcodeGen installed via ARM64 Homebrew"
              else
                echo "‚ùå All installation methods failed"
                exit 1
              fi
            # Strategy 3: Standard Homebrew
            else
              echo "Trying standard Homebrew..."
              if brew install xcodegen; then
                echo "‚úÖ XcodeGen installed via standard Homebrew"
              else
                echo "‚ùå Homebrew installation failed"
                exit 1
              fi
            fi
          else
            echo "‚úÖ XcodeGen already available"
          fi
          xcodegen generate
          
      - name: Monitor test performance
        run: |
          echo "Starting test performance monitoring..."
          
          # Record start time
          TEST_START_TIME=$(date +%s)
          
          # Find the best available iOS 26.0 simulator for unit test performance monitoring
          echo "Looking for available iOS 26.0 simulators for unit test performance monitoring..."
          
          # Check for iPhone 16 Pro with iOS 26.0 first (preferred)
          if xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone 16 Pro.*26.0"; then
            DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro,OS=26.0"
            echo "‚úÖ Found iPhone 16 Pro with iOS 26.0 - using preferred target for unit test performance monitoring"
          # Fallback to any iPhone with iOS 26.0
          elif xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone.*26.0"; then
            # Get first available iPhone with iOS 26.0
            IPHONE_26_LINE=$(xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep "iPhone.*26.0" | head -1)
            IPHONE_NAME=$(echo "$IPHONE_26_LINE" | grep -o 'name:[^,]*' | cut -d: -f2)
            DESTINATION="platform=iOS Simulator,name=$IPHONE_NAME,OS=26.0"
            echo "‚úÖ Found $IPHONE_NAME with iOS 26.0 - using fallback target for unit test performance monitoring"
          else
            echo "‚ùå No iOS 26.0 simulators found, skipping unit test performance monitoring"
            exit 0
          fi
          
          echo "Running unit tests with destination: $DESTINATION"
          xcodebuild test \
            -project "${{ env.PROJECT_NAME }}.xcodeproj" \
            -scheme "${{ env.SCHEME_NAME }}" \
            -destination "$DESTINATION" \
            -only-testing:"${{ env.SCHEME_NAME }}Tests" \
            -resultBundlePath UnitTestResults.xcresult \
            CODE_SIGNING_ALLOWED=NO \
            ONLY_ACTIVE_ARCH=YES \
            VALID_ARCHS="arm64" \
            ARCHS="arm64" \
            ENABLE_BITCODE=NO \
            IPHONEOS_DEPLOYMENT_TARGET=26.0
            
          # Record unit test time
          UNIT_TEST_END_TIME=$(date +%s)
          UNIT_TEST_DURATION=$((UNIT_TEST_END_TIME - TEST_START_TIME))
          
          # Find the best available iOS 26.0 simulator for UI test performance monitoring
          echo "Looking for available iOS 26.0 simulators for UI test performance monitoring..."
          
          # Check for iPhone 16 Pro with iOS 26.0 first (preferred)
          if xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone 16 Pro.*26.0"; then
            DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro,OS=26.0"
            echo "‚úÖ Found iPhone 16 Pro with iOS 26.0 - using preferred target for UI test performance monitoring"
          # Fallback to any iPhone with iOS 26.0
          elif xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep -q "iPhone.*26.0"; then
            # Get first available iPhone with iOS 26.0
            IPHONE_26_LINE=$(xcodebuild -showdestinations -scheme "${{ env.SCHEME_NAME }}" -project "${{ env.PROJECT_NAME }}.xcodeproj" 2>/dev/null | grep "iPhone.*26.0" | head -1)
            IPHONE_NAME=$(echo "$IPHONE_26_LINE" | grep -o 'name:[^,]*' | cut -d: -f2)
            DESTINATION="platform=iOS Simulator,name=$IPHONE_NAME,OS=26.0"
            echo "‚úÖ Found $IPHONE_NAME with iOS 26.0 - using fallback target for UI test performance monitoring"
          else
            echo "‚ùå No iOS 26.0 simulators found, skipping UI test performance monitoring"
            exit 0
          fi
          
          echo "Running UI tests with destination: $DESTINATION"
          xcodebuild test \
            -project "${{ env.PROJECT_NAME }}.xcodeproj" \
            -scheme "${{ env.SCHEME_NAME }}" \
            -destination "$DESTINATION" \
            -only-testing:"${{ env.SCHEME_NAME }}UITests" \
            -resultBundlePath UITestResults.xcresult \
            CODE_SIGNING_ALLOWED=NO \
            ONLY_ACTIVE_ARCH=YES \
            VALID_ARCHS="arm64" \
            ARCHS="arm64" \
            ENABLE_BITCODE=NO \
            IPHONEOS_DEPLOYMENT_TARGET=26.0
            
          # Record end time
          TEST_END_TIME=$(date +%s)
          UI_TEST_DURATION=$((TEST_END_TIME - UNIT_TEST_END_TIME))
          TOTAL_TEST_DURATION=$((TEST_END_TIME - TEST_START_TIME))
          
          # Output performance metrics
          echo "## Test Performance Metrics"
          echo "==========================="
          echo "üß™ **Unit Test Duration**: ${UNIT_TEST_DURATION} seconds"
          echo "üñ•Ô∏è **UI Test Duration**: ${UI_TEST_DURATION} seconds"
          echo "‚è±Ô∏è **Total Test Duration**: ${TOTAL_TEST_DURATION} seconds"
          echo ""
          echo "## Test Performance Analysis"
          echo "============================"
          
          # Analyze performance
          if [ $TOTAL_TEST_DURATION -lt 30 ]; then
            echo "‚úÖ Test performance: EXCELLENT (< 30 seconds)"
          elif [ $TOTAL_TEST_DURATION -lt 60 ]; then
            echo "‚úÖ Test performance: GOOD (< 1 minute)"
          elif [ $TOTAL_TEST_DURATION -lt 180 ]; then
            echo "‚ö†Ô∏è Test performance: ACCEPTABLE (< 3 minutes)"
          else
            echo "‚ùå Test performance: POOR (> 3 minutes)"
          fi
          
          # Performance recommendations
          echo ""
          echo "## Test Performance Recommendations"
          echo "==================================="
          if [ $TOTAL_TEST_DURATION -gt 60 ]; then
            echo "üîß Consider parallel test execution"
            echo "üîß Review test dependencies and setup"
            echo "üîß Consider test optimization and mocking"
          fi
          
          # Store metrics for reporting
          echo "UNIT_TEST_DURATION=${UNIT_TEST_DURATION}" >> $GITHUB_ENV
          echo "UI_TEST_DURATION=${UI_TEST_DURATION}" >> $GITHUB_ENV
          echo "TOTAL_TEST_DURATION=${TOTAL_TEST_DURATION}" >> $GITHUB_ENV

  # Resource usage monitoring
  resource-monitor:
    name: Resource Monitor
    runs-on: macos-latest
    if: github.event.inputs.monitor_type == 'resource' || github.event.inputs.monitor_type == 'full' || github.event_name == 'schedule'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Monitor system resources
        run: |
          echo "Starting resource usage monitoring..."
          
          # System information
          echo "## System Information"
          echo "===================="
          echo "üñ•Ô∏è **OS Version**: $(sw_vers -productVersion)"
          echo "üíª **Hardware**: $(system_profiler SPHardwareDataType | grep "Model Name" | cut -d: -f2 | xargs)"
          echo "üß† **Memory**: $(system_profiler SPHardwareDataType | grep "Memory" | cut -d: -f2 | xargs)"
          echo "üíæ **Storage**: $(df -h / | tail -1 | awk '{print $4 " available"}')"
          echo ""
          
          # CPU usage monitoring
          echo "## CPU Usage Monitoring"
          echo "======================"
          echo "üìä **CPU Usage**: $(top -l 1 | grep "CPU usage" | awk '{print $3}' | sed 's/%//')"
          echo "üî• **Load Average**: $(uptime | awk '{print $(NF-2), $(NF-1), $NF}')"
          echo ""
          
          # Memory usage monitoring
          echo "## Memory Usage Monitoring"
          echo "=========================="
          echo "üß† **Memory Usage**: $(vm_stat | grep "Pages free" | awk '{print $3}' | sed 's/\.//') pages free"
          echo "üíæ **Swap Usage**: $(vm_stat | grep "Swapouts" | awk '{print $2}' | sed 's/\.//') swapouts"
          echo ""
          
          # Disk usage monitoring
          echo "## Disk Usage Monitoring"
          echo "======================="
          echo "üíæ **Disk Usage**: $(df -h / | tail -1 | awk '{print $5 " used"}')"
          echo "üìÅ **Home Directory**: $(du -sh ~ | awk '{print $1}')"
          echo ""
          
          # Network monitoring
          echo "## Network Monitoring"
          echo "===================="
          echo "üåê **Network Interfaces**: $(ifconfig | grep "inet " | wc -l) active interfaces"
          echo "üì° **Network Status**: $(ping -c 1 8.8.8.8 > /dev/null 2>&1 && echo "Connected" || echo "Disconnected")"
          echo ""
          
          # Performance recommendations
          echo "## Resource Optimization Recommendations"
          echo "======================================="
          
          # Check available memory
          AVAILABLE_MEMORY=$(vm_stat | grep "Pages free" | awk '{print $3}' | sed 's/\.//')
          if [ "$AVAILABLE_MEMORY" -lt 1000000 ]; then
            echo "‚ö†Ô∏è Low available memory - consider memory optimization"
          else
            echo "‚úÖ Sufficient memory available"
          fi
          
          # Check disk space
          DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
          if [ "$DISK_USAGE" -gt 80 ]; then
            echo "‚ö†Ô∏è High disk usage - consider cleanup"
          else
            echo "‚úÖ Sufficient disk space available"
          fi
          
          echo ""
          echo "## Performance Best Practices"
          echo "============================"
          echo "üîß Use caching for build artifacts"
          echo "üîß Optimize test execution with parallelization"
          echo "üîß Monitor resource usage during builds"
          echo "üîß Clean up temporary files regularly"
          echo "üîß Use appropriate runner types for different tasks"

  # Performance summary and reporting
  performance-summary:
    name: Performance Summary
    runs-on: ubuntu-latest
    needs: [build-performance, test-performance, resource-monitor]
    if: always()
    
    steps:
      - name: Performance Summary Report
        run: |
          echo "## Performance Monitoring Summary"
          echo "================================="
          echo "üìä **Build Performance**: ${{ needs.build-performance.result }}"
          echo "üß™ **Test Performance**: ${{ needs.test-performance.result }}"
          echo "üíª **Resource Monitoring**: ${{ needs.resource-monitor.result }}"
          echo ""
          
          # Overall performance status
          if [[ "${{ needs.build-performance.result }}" == "success" && \
                "${{ needs.test-performance.result }}" == "success" && \
                "${{ needs.resource-monitor.result }}" == "success" ]]; then
            echo "üéâ All performance monitoring completed successfully!"
            echo "‚úÖ Crown & Barrel iOS app performance status: OPTIMAL"
          else
            echo "‚ö†Ô∏è Some performance monitoring failed or has warnings."
            echo "üîç Please review the performance monitoring results above."
            echo "‚ùå Crown & Barrel iOS app performance status: NEEDS ATTENTION"
          fi
          
          echo ""
          echo "## Performance Recommendations"
          echo "============================="
          echo "1. **Build Optimization**: Implement caching and parallelization"
          echo "2. **Test Optimization**: Use parallel test execution"
          echo "3. **Resource Management**: Monitor and optimize resource usage"
          echo "4. **Regular Monitoring**: Run performance monitoring regularly"
          echo "5. **Performance Baselines**: Establish and track performance baselines"
          echo "6. **Continuous Improvement**: Regularly review and optimize performance"
          
          echo ""
          echo "## Next Steps"
          echo "============"
          echo "üîß Review performance metrics and identify optimization opportunities"
          echo "üìà Establish performance baselines and monitoring alerts"
          echo "üöÄ Implement performance optimizations based on findings"
          echo "üìä Set up continuous performance monitoring and reporting"
